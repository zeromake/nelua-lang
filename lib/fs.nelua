require 'string'
require 'C.stdlib'
require 'allocators.default'

local fs = @record{}

local fs.constants = @record{}
local fs.constants.F_OK: integer = 0
local fs.constants.R_OK: integer = 2
local fs.constants.W_OK: integer = 4
local fs.constants.X_OK: integer = 8
local fs.constants.S_IFLNK: integer = 0xA000
local fs.constants.S_IFDIR: integer = 0x4000
local fs.constants.S_IFREG: integer = 0x8000

local fs.Stats = @record{
    dev: uinteger,
    ino: uinteger,
    mode: uinteger,
    nlink: integer,
    uid: integer,
    gid: integer,
    rdev: integer,
    size: int64,
    blksize: integer,
    blocks: integer,
    ctime: int64,
    mtime: int64,
    atime: int64,
    birthtime: int64
}

local fs.Dirent = @record{
    name: string,
    path: string,
    size: int64,
    ctime: int64,
    mtime: int64,
    atime: int64
}

local fs.RmOptions = @record{
    recursive: boolean
}

## if ccinfo.is_windows then

local ULARGE_PART = @record{
    LowPart: culong,
    HighPart: culong
}

local ULARGE_INTEGER = @union{
    u: ULARGE_PART,
    QuadPart: culonglong
}


local function access(path: cstring, mode: cint): cint <cimport'_access',cinclude'<io.h>'> end
local function unlink(path: cstring): cint <cimport'_unlink',cinclude'<stdio.h>'> end
local FILE_FLAG_BACKUP_SEMANTICS: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_FLAG_OPEN_REPARSE_POINT: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_READ_ATTRIBUTES: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_SHARE_READ: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_SHARE_WRITE: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_SHARE_DELETE: culong <cimport,nodecl,cinclude'<windows.h>'>
local INVALID_FILE_ATTRIBUTES: culong <cimport,nodecl,cinclude'<windows.h>'>
local OPEN_EXISTING: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_ATTRIBUTE_REPARSE_POINT: culong <cimport,nodecl,cinclude'<windows.h>'>
local FILE_ATTRIBUTE_DIRECTORY: culong <cimport,nodecl,cinclude'<windows.h>'>
local INVALID_HANDLE_VALUE: pointer <cimport,nodecl,cinclude'<windows.h>'>
local MAXDWORD: culong <cimport,nodecl,cinclude'<windows.h>'>

local FILETIME: type <cimport,cinclude'<windows.h>',cincomplete> = @record{
    dwLowDateTime: culong,
    dwHighDateTime: culong
}
local function filetime_to_ms(t: FILETIME): int64
    local ui: ULARGE_INTEGER;
    ui.u.HighPart = t.dwHighDateTime
    ui.u.LowPart = t.dwLowDateTime
    return (ui.QuadPart - 116444736000000000) / 10000
end

local BY_HANDLE_FILE_INFORMATION: type <cimport,cinclude'<windows.h>',cincomplete> = @record{
    dwFileAttributes: culong,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    dwVolumeSerialNumber: culong,
    nFileSizeHigh: culong,
    nFileSizeLow: culong,
    nNumberOfLinks: culong,
    nFileIndexHigh: culong,
    nFileIndexLow: culong,
}

local function GetFileInformationByHandle(
    hFile: pointer <const>,
    lpFileInformation: *BY_HANDLE_FILE_INFORMATION
): cint <cimport,cinclude'<windows.h>'> end

local function CreateFileA(
    lpFileName: cstring <const>,
    dwDesiredAccess: culong,
    dwShareMode: culong,
    lpSecurityAttributes: pointer,
    dwCreationDisposition: culong,
    dwFlagsAndAttributes: culong,
    hTemplateFile: pointer
): pointer <cimport,cinclude'<windows.h>'> end
local function GetLastError(): culong <cimport,cinclude'<windows.h>'> end
local function FormatMessageA(
    dwFlags: culong,
    lpSource: pointer,
    dwMessageId: culong,
    dwLanguageId: culong,
    lpBuffer: cstring,
    nSize: culong,
    Arguments: pointer
): culong <cimport,cinclude'<windows.h>'> end
local function wingeterrno(): (string, integer)
    local err = GetLastError()
    local msg = string.create(256)
    local size = FormatMessageA(
        0x00001000,
        nilptr,
        err,
        1033,
        msg.data,
        256,
        nilptr
    )
    return msg:subview(0, size), err
end

local SymbolicLinkReparseBuffer = @record{
    SubstituteNameOffset: cushort,
    SubstituteNameLength: cushort,
    PrintNameOffset: cushort,
    PrintNameLength: cushort,
    Flags: culong,
    PathBuffer: cchar[1]
}
local MountPointReparseBuffer = @record{
    SubstituteNameOffset: cushort,
    SubstituteNameLength: cushort,
    PrintNameOffset: cushort,
    PrintNameLength: cushort,
    PathBuffer: cchar[1]
}

local GenericReparseBuffer = @record{
    PathBuffer: cchar[1]
}

local REPARSE_BUFFER = @union{
    SymbolicLinkReparseBuffer: SymbolicLinkReparseBuffer,
    MountPointReparseBuffer: MountPointReparseBuffer,
    GenericReparseBuffer: GenericReparseBuffer
}

local REPARSE_DATA_BUFFER = @record{
    ReparseTag: culong,
    ReparseDataLength: cushort,
    Reserved: cushort,
    DUMMY: REPARSE_BUFFER
}

local function DeviceIoControl(
    hDevice: pointer,
    dwIoControlCode: culong,
    lpInBuffer: pointer <const>,
    nInBufferSize: culong,
    lpOutBuffer: pointer,
    nOutBufferSize: culong,
    lpBytesReturned: *culong,
    lpOverlapped: pointer
): cint <cimport,cinclude'<windows.h>'> end

local 

## else
local function access(path: cstring, mode: cint): cint <cimport,cinclude'<unistd.h>'> end
local function unlink(path: cstring): cint <cimport,cinclude'<unistd.h>'> end
local timespec: type <cimport,cinclude'<sys/stat.h>',ctypedef,cincomplete> = @record{
    tv_sec: clong,
    tv_nsec: clong
}
## if ccinfo.is_apple then
## cdefine '_DARWIN_C_SOURCE'
local StatRecord: type <cimport,cinclude'<sys/stat.h>',ctypedef'stat'> = @record{
    st_dev: cint,
    st_ino: culonglong,
    st_mode: cushort,
    st_nlink: cushort,
    st_uid: cuint,
    st_gid: cuint,
    st_rdev: cint,
    st_size: clonglong,
    st_blocks: clonglong,
    st_blksize: cint,
    st_atimespec: timespec,
    st_mtimespec: timespec,
    st_ctimespec: timespec,
    st_birthtimespec: timespec
}
## else
local StatRecord: type <cimport,cinclude'<sys/stat.h>',ctypedef'stat'> = @record{
    st_dev: cint,
    st_ino: culonglong,
    st_mode: cushort,
    st_nlink: cushort,
    st_uid: cuint,
    st_gid: cuint,
    st_rdev: cint,
    st_size: clonglong,
    st_blocks: clonglong,
    st_blksize: cint,
    st_atim: timespec,
    st_mtim: timespec,
    st_ctim: timespec
}
## end
local function st_lstat(path: cstring, st: *StatRecord): cint <cimport'lstat',cinclude'<sys/stat.h>'> end
local function st_stat(path: cstring, st: *StatRecord): cint <cimport'stat',cinclude'<sys/stat.h>'> end
local function timespec_to_ms(tv: timespec): int64
    return tv.tv_sec * 1000 + (tv.tv_nsec / 1000000);
end
## end

local function geterrno(): (string, integer)
    local errno: cint <cimport,cinclude'<errno.h>'>
    local function strerror(errnum: cint): cstring <cimport,cinclude'<string.h>'> end
    return strerror(errno), errno
end


function fs.access(path: string, mode: facultative(integer)): (boolean, string, integer)
## if mode.type.is_niltype then
    local mode = fs.constants.F_OK
## end
    if access(path, mode) == 0 then
        return true, '', 0
    end
    return false, geterrno()
end

function fs.exists(path: string): boolean
    local ok = fs.access(path)
    return ok
end

local function common_stat(path: string, is_lstat: boolean): (*fs.Stats, string, integer)
## if ccinfo.is_windows then
    local flags = FILE_FLAG_BACKUP_SEMANTICS
    if is_lstat then
        flags = flags | FILE_FLAG_OPEN_REPARSE_POINT
    end
    local handle = CreateFileA(
        path,
        FILE_READ_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nilptr,
        OPEN_EXISTING,
        flags,
        nilptr
    )
    if handle == nilptr or handle == INVALID_HANDLE_VALUE then
        return nilptr, wingeterrno()
    end
    local info: BY_HANDLE_FILE_INFORMATION
    if GetFileInformationByHandle(
        handle,
        &info
    ) == 0 then
        return nilptr, wingeterrno()
    end
    local st = default_allocator:new(@fs.Stats)
    if info.dwFileAttributes ~= INVALID_FILE_ATTRIBUTES then
        if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT then
            st.mode = st.mode | fs.constants.S_IFLNK
        end
        if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY then
            st.mode = st.mode | fs.constants.S_IFDIR;
        else
            st.mode = st.mode | fs.constants.S_IFREG;
        end
    end
    st.dev = info.dwVolumeSerialNumber
    st.size = (info.nFileSizeHigh * (MAXDWORD + 1)) + info.nFileSizeLow
    st.ino = (info.nFileIndexHigh * (MAXDWORD + 1)) + info.nFileIndexLow
    st.nlink = info.nNumberOfLinks
    st.atime = filetime_to_ms(info.ftLastAccessTime)
    st.mtime = filetime_to_ms(info.ftLastWriteTime)
    st.ctime = filetime_to_ms(info.ftCreationTime)
    return st, '', 0
## else
    local s: StatRecord
    local res: cint
    if is_lstat then
        res = st_lstat(path, &s)
    else
        res = st_stat(path, &s)
    end
    if res ~= 0 then
        return nilptr, geterrno()
    end
    local st = default_allocator:new(@fs.Stats)
    st.dev = s.st_dev
    st.ino = s.st_ino
    st.mode = s.st_mode
    st.nlink = s.st_nlink
    st.uid = s.st_uid
    st.gid = s.st_gid
    st.rdev = s.st_rdev
    st.size = s.st_size
    st.blksize = s.st_blksize
    st.blocks = s.st_blocks
## if ccinfo.is_apple then
    st.atime = timespec_to_ms(s.st_atimespec)
    st.mtime = timespec_to_ms(s.st_mtimespec)
    st.ctime = timespec_to_ms(s.st_ctimespec)
    st.birthtime = timespec_to_ms(s.st_birthtimespec)
## else
    st.atime = timespec_to_ms(s.st_atim)
    st.mtime = timespec_to_ms(s.st_mtim)
    st.ctime = timespec_to_ms(s.st_ctim)
## end
    return st, '', 0
## end
end

function fs.stat(path: string): (*fs.Stats, string, integer)
    return common_stat(path, false)
end

function fs.lstat(path: string): (*fs.Stats, string, integer)
    return common_stat(path, true)
end

function fs.rm(path: string, options: facultative(fs.RmOptions)): (boolean, string, integer)
## if options.type.is_niltype then
    local options = (@fs.RmOptions){
        recursive = false
    }
## end
    local stat, msg, code = fs.stat(path)
    if code ~= 0 then
        return false, msg, code
    end
end

return fs
